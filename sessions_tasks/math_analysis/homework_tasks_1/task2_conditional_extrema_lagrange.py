"""
Условие задания № 2:
    Найдите условные экстремумы функции
        f(x, y) = 4*x + 8*y
    при ограничении
        g(x, y) = y**2 - 2*x*y + 5 = 0

    Требование: вычислить результат вручную и с помощью Python. Сравнить результаты.
"""

import sympy as sp


def main() -> None:
    """
    Этапы решения:
        1) Ручной путь (исключение x из ограничения -> одномерная задача по y).
        2) Метод множителей Лагранжа (символьное решение в SymPy).
        3) Сравнение результатов и классификация (локальный min/max по ограничению).

    Результат вывода:
        === Ручное решение ===
        Точка: x=-3, y=-1;  f=-20;  классификация: локальный максимум (по ограничению)
        Точка: x=3, y=1;  f=20;  классификация: локальный минимум (по ограничению)

        === Множители Лагранжа (SymPy) ===
        df/dx + lam*dg/dx = dL/dx = -2*lam*y + 4
        df/dy + lam*dg/dy = dL/dy = lam*(-2*x + 2*y) + 8
        Ограничение: g(x,y) = 0 -> -2*x*y + y**2 + 5 = 0

        Решения системы Лагранжа:
        x=-3, y=-1, f=-20
        x=3, y=1, f=20

        === Сравнение результатов (ручной метод против Лагранжа) ===
        Совпадают ли точки и значения f? -> True

        === Классификация (по ограничению) ===
        Точка (x=-3, y=-1): f=-20 -> локальный максимум (по ограничению)
        Точка (x=3, y=1): f=20 -> локальный минимум (по ограничению)

        === Итог ===
        1) Условные стационарные точки по ограничению g(x, y) = 0:
           - (x, y) = (3, 1), f = 20 -> локальный минимум по ограничению
           - (x, y) = (-3, -1), f = -20 -> локальный максимум по ограничению
        2) По множеству g = 0 функция неограничена сверху и снизу, то есть глобальных экстремумов нет
        3) Ручной расчет и метод Лагранжа дают одинаковые точки и значения f
    """

    # Задаем переменные и функции (lam - множитель Лагранжа, то есть на сколько сильно ограничение влияет на экстремум)
    x, y, lam = sp.symbols("x y lam", real=True)
    f = 4 * x + 8 * y
    g = y ** 2 - 2 * x * y + 5

    # 1) РУЧНОЙ ПУТЬ: сводим задачу к одной переменной
    # Ограничение (получаем x): y**2 - 2*x*y + 5 = 0  =>  2*x*y = y**2 + 5  =>  x = (y**2 + 5)/(2*y), y != 0
    # Тогда f(x,y) -> phi(y) = 4*x + 8*y = 4*((y**2 + 5)/(2y)) + 8*y = 10*y + 10/y.
    # Критические точки: phi'(y) = 10 - 10/y**2 = 0  =>  y**2 = 1 => y1 = 1, y2 = -1
    # Соответствующие x: x = (y**2 + 5)/(2*y) = y/2 + 5/(2*y) => x = 3 (для y=1), x = -3 (для y=-1).
    # Значения f: f(3,1)=20, f(-3,-1)=-20.
    # Классификация по второму производному phi''(y) = 20/y**3:
    #   y = 1: phi'' = 20 > 0 -> локальный минимум (по ограничению); значение 20.
    #   y = -1: phi'' = -20 < 0 -> локальный максимум (по ограничению); значение -20.
    # Глобально по множеству g = 0 функция не ограничена (вверх на y > 0, вниз на y < 0), поэтому глобальных экстремумов нет.

    print("=== Ручное решение ===")
    # Функция нескольких переменных f(x, y) преобразуется в функцию одной переменной phi(y)
    # за счет использования ограничения, которое связывает переменные.
    phi = 10 * y + 10 / y
    dphi = sp.diff(phi, y)
    d2phi = sp.diff(dphi, y)

    # Критические y (производная обращается в ноль или не существует)
    crit_y = sp.solve(sp.Eq(dphi, 0), y)
    # Точки и значения
    manual_points = []
    for yy in crit_y:
        # Исключаем y = 0 (он не корень уравнения dphi = 0)
        xx = (yy ** 2 + 5) / (2 * yy)
        val = f.subs({x: xx, y: yy})
        # Классификация по знаку второй производной
        second = d2phi.subs(y, yy)
        if second > 0:
            cls = "локальный минимум (по ограничению)"
        elif second < 0:
            cls = "локальный максимум (по ограничению)"
        else:
            cls = "неопределено"
        manual_points.append((sp.simplify(xx), sp.simplify(yy), sp.simplify(val), cls))

    for xx, yy, val, cls in manual_points:
        print(f"Точка: x={xx}, y={yy};  f={val};  классификация: {cls}")

    # 2) МЕТОД ЛАГРАНЖА: L = f + lam*g
    # Уравнения: dL/dx = 0, dL/dy = 0, g = 0
    # dL/dx = 4 + lam*(-2*y) = 0 -> 4 - 2*lam*y = 0
    # dL/dy = 8 + lam*(2*y - 2*x) = 0
    # g(x,y) = 0

    L = f + lam * g
    dLdx = sp.diff(L, x)
    dLdy = sp.diff(L, y)

    print("\n=== Множители Лагранжа (SymPy) ===")
    print(f"df/dx + lam*dg/dx = dL/dx = {dLdx}")
    print(f"df/dy + lam*dg/dy = dL/dy = {dLdy}")
    print(f"Ограничение: g(x,y) = 0 -> {g} = 0")

    sol = sp.solve([sp.Eq(dLdx, 0), sp.Eq(dLdy, 0), sp.Eq(g, 0)], (x, y, lam), dict=True)

    if not sol:
        print("Решений по Лагранжу не найдено")
        return

    print("\nРешения системы Лагранжа:")
    lagrange_points = []
    for s in sol:
        xx = sp.simplify(s[x])
        yy = sp.simplify(s[y])
        ff = sp.simplify(f.subs({x: xx, y: yy}))
        lagrange_points.append((xx, yy, ff))
        print(f"x={xx}, y={yy}, f={ff}")

    # 3) Сравнение и итоговые выводы

    print("\n=== Сравнение результатов (ручной метод против Лагранжа) ===")
    manual_set = {(sp.simplify(a), sp.simplify(b), sp.simplify(c)) for a, b, c, _ in manual_points}
    lagr_set = {(sp.simplify(a), sp.simplify(b), sp.simplify(c)) for a, b, c in lagrange_points}
    print(f"Совпадают ли точки и значения f? -> {manual_set == lagr_set}")

    print("\n=== Классификация (по ограничению) ===")
    for xx, yy, ff in lagrange_points:
        # Используем одномерный тест второй производной для phi(y) = 10*y + 10/y
        sign = d2phi.subs(y, yy)
        if sign > 0:
            cls = "локальный минимум (по ограничению)"
        elif sign < 0:
            cls = "локальный максимум (по ограничению)"
        else:
            cls = "неопределено"
        print(f"Точка (x={xx}, y={yy}): f={ff} -> {cls}")

    print("\n=== Итог ===")
    print("1) Условные стационарные точки по ограничению g(x, y) = 0:")
    print("   - (x, y) = (3, 1),   f = 20 -> локальный минимум по ограничению")
    print("   - (x, y) = (-3, -1), f = -20 -> локальный максимум по ограничению")
    print("2) По множеству g = 0 функция неограничена сверху и снизу, то есть глобальных экстремумов нет")
    print("3) Ручной расчет и метод Лагранжа дают одинаковые точки и значения f")


if __name__ == "__main__":
    main()
