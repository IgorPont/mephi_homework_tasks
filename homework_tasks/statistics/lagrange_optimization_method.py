"""
Решение задачи условной оптимизации по методу Лагранжа.

Условие:
    У нас есть два станка для производства пластиковых упаковок. Станки разных моделей,
    поэтому при их использовании получаются разные издержки, зависящие от произведённых упаковок и
    выражаемые следующими функциями:
        g(a) = 3*a**2 + a # количество упаковок, произведенных на первом станке
        g(b) = 4*b + 5*b**2 # количество упаковок, произведенных на втором станке

        w - множитель Лагранжа # обозначим его этой переменной

    Нам заказали 200 упаковок. Мы хотим выполнить заказ, минимизировав расходы на изготовление товаров.
    Чтобы узнать, как мы можем сэкономить, необходимо решить задачу оптимизации.
        То есть функция ограничений будет вот такой: a + b = 200 (обозначим ее переменной q)
"""

from sympy import *

# # Задаем переменные
# a, b, w = symbols('a b w')
#
# # Строим целевую функцию
# g = 3 * a ** 2 + a + 4 * b + 5 * b ** 2
# print('Целевая функция для аргументов a и b :\n f = ', g)
#
# # Задаем функцию ограничений
# q = a + b - 200
# print('Функция ограничений: ', q, '= 0')
#
# # Строим функцию Лагранжа
# f = 3 * a ** 2 + a + 4 * b + 5 * b ** 2 + w * (a + b - 200)
# print('Функция Лагранжа:\n ', f)
#
# # Находим производную по a
# fa = f.diff(a)
# print('df/da =', fa, '= 0')
#
# # Находим производную по b
# fb = f.diff(b)
# print('df/db =', fb, '= 0')
#
# # Находим производную по w
# fw = f.diff(w)
# print('df/dw =', fw, '= 0')
#
# # Решаем систему уравнений и находим точку минимума
# # она же по модулю - точка максимума, то есть максимальное количество упаковох,
# # которые можно произвести на каждом станке
# sols = solve([fa, fb, fw], a, b, w)
# print('Стационарная точка M(a,b):\n', float(sols[a]), ',', float(sols[b]))


"""
Допустим, вы хотите произвести некоторое количество товара, которое зависит от часов работы двух ключевых сотрудников 
следующим образом:

    f(x, y) = x**2 + 2*y**2


где x — время работы 1-ого сотрудника, y — время работы 2-ого сотрудника.

Однако вы должны оплатить этим сотрудникам ровно 20 часов работы в сумме, то есть:

    x + y = 20

Какое наибольшее количество товаров вы сможете произвести в таком случае?

Помните, что количество часов работы должно быть целым, поэтому, прежде чем вычислять итоговый результат, 
округлите часы работы до целого.
"""

# --------------------------------------------
# Задача: максимизировать f(x,y) = x^2 + 2y^2
# при ограничении x + y = 20 (целые x,y)
# --------------------------------------------

from sympy import symbols, diff, solve, Matrix, N

# 1) Объявляем переменные
# real=True — переменные вещественные; w — множитель Лагранжа
x, y, w = symbols('x y w', real=True)

# 2) Целевая функция (то, что хотим максимизировать/минимизировать)
f = x ** 2 + 2 * y ** 2

# 3) Ограничение: x + y = 20  ->  перепишем как g(x,y) = x + y - 20 = 0
g = x + y - 20

# 4) Лагранжиан: L = f + w * g
# (множитель Лагранжа добавляет ограничение в цель через w)
L = f + w * g

# 5) Стационарные условия (∂L/∂x = 0, ∂L/∂y = 0, ∂L/∂w = 0)
Lx = diff(L, x)  # 2x + w
Ly = diff(L, y)  # 4y + w
Lw = diff(L, w)  # x + y - 20

# 6) Решаем систему уравнений — получаем кандидата на экстремум на множестве g=0
sol = solve([Lx, Ly, Lw], (x, y, w), dict=True)[0]
x_star = sol[x]
y_star = sol[y]
w_star = sol[w]

print("Стационарная точка (по Лагранжу):")
print(f"x* = {x_star}, y* = {y_star}, w* = {w_star}")
print(f"f(x*, y*) = {f.subs({x: x_star, y: y_star})} ≈ {N(f.subs({x: x_star, y: y_star}))}")

# -------------------------------
# МЕТОД 1: Сведение к одномерной задаче
# -------------------------------
# Идея: из ограничения y = 20 - x, тогда F(x) = f(x, 20 - x)
# Классификация: F''(x*) > 0 => минимум, F''(x*) < 0 => максимум

F = (x ** 2 + 2 * (20 - x) ** 2)  # подставили y = 20 - x
Fx = diff(F, x)  # первая производная F'(x)
Fxx = diff(Fx, x)  # вторая производная F''(x)

# Находим критические точки F'(x)=0 (они согласованы с решением по Лагранжу)
crit_1d = solve(Fx, x)

print("\n[Метод 1] Одномерное исследование вдоль прямой x+y=20")
print(f"F(x)   = {F}")
print(f"F'(x)  = {Fx}")
print(f"F''(x) = {Fxx}")
print(f"Критические точки F'(x)=0: {crit_1d}")

# Берём ту, которая совпадает с x_star
Fxx_at_star = Fxx.subs(x, x_star)
kind_1d = "минимум" if Fxx_at_star > 0 else ("максимум" if Fxx_at_star < 0 else "неопределено")
print(f"Классификация по F''(x*): F''(x*) = {Fxx_at_star} -> {kind_1d}")

# -------------------------------
# МЕТОД 2: Касательное направление + Гессиан
# -------------------------------
# Идея: для равенства g(x,y)=0 касательное направление t удовлетворяет grad g · t = 0.
# Для g = x + y - 20 имеем grad g = (1, 1). Любой вектор t с t_x + t_y = 0 — допустимый.
# Удобный выбор: t = (1, -1).
#
# Вторая вариация вдоль допустимого направления:  q = t^T * H_f * t.
# Если q > 0 — минимум на множестве g=0; q < 0 — максимум; q = 0 — нужен более тонкий анализ.

# Гессиан цели f: H_f = [[f_xx, f_xy],[f_yx, f_yy]]
f_xx = diff(f, x, x)  # 2
f_xy = diff(f, x, y)  # 0
f_yy = diff(f, y, y)  # 4
Hf = Matrix([[f_xx, f_xy],
             [f_xy, f_yy]])

# Касательный вектор к прямой x+y=20: t = (1, -1) (он ортогонален grad g = (1,1))
t = Matrix([1, -1])

# Квадратичная форма во втором порядке (вторая вариация вдоль допустимого направления)
q = (t.T * Hf * t)[0]  # скаляр

print("\n[Метод 2] Проекция второй вариации на касательное направление")
print(f"Гессиан H_f =\n{Hf}")
print(f"Касательный вектор t = {t.T}")
print(f"q = t^T * H_f * t = {q} -> {'минимум' if q > 0 else ('максимум' if q < 0 else 'неопределено')}")

# Замечание: здесь H_f — константная матрица, поэтому q не зависит от точки; если q>0, это минимум вдоль прямой.

# -------------------------------
# ПОИСК ИСТИННОГО МАКСИМУМА НА ЦЕЛОЧИСЛЕННОЙ РЕШЁТКЕ
# -------------------------------
# По условию задачи x и y — целые часы. Значит, нужно проверить все пары (x, y), x>=0, y>=0, x+y=20.
# Это небольшая решётка из 21 точки, легко перебрать.

best_val = None
best_xy = None
vals = []
for xi in range(0, 21):  # x = 0..20
    yi = 20 - xi  # y = 20 - x
    val = f.subs({x: xi, y: yi})
    vals.append((xi, yi, val))
    if best_val is None or val > best_val:
        best_val = val
        best_xy = (xi, yi)

print("\n[Целочисленный поиск] Перебор точек на x+y=20:")
for xi, yi, val in vals:
    mark = "  <-- максимум" if (xi, yi) == best_xy else ""
    print(f"x={xi:2d}, y={yi:2d} -> f={val}{mark}")

print(f"\nИтог (целые часы): максимум f достигается при x={best_xy[0]}, y={best_xy[1]}, значение f = {best_val}")
